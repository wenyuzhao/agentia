from pathlib import Path
from typing import (
    Annotated,
    Literal,
    Required,
    TypeAlias,
    TypeGuard,
    TypeVar,
    TypedDict,
    Union,
    Sequence,
    Any,
)
import json
from dataclasses import dataclass, field
import uuid
from pydantic import BaseModel, Field


class FunctionCallDict(TypedDict, total=False):
    arguments: Required[str]
    """
    The arguments to call the function with, as generated by the model in JSON
    format. Note that the model does not always generate valid JSON, and may
    hallucinate parameters not defined by your function schema. Validate the
    arguments in your code before calling your function.
    """

    name: Required[str]
    """The name of the function to call."""


class FunctionCall(BaseModel):
    name: str
    arguments: Any


class ToolCall(BaseModel):
    id: str
    function: FunctionCall
    type: Literal["function"] = "function"


Role: TypeAlias = Literal["system", "user", "assistant", "tool"]


class ContentPartText(BaseModel):
    content: str
    type: Literal["text"] = "text"


class ContentPartImage(BaseModel):
    url: str
    type: Literal["image"] = "image"


ContentPart = Annotated[
    Union[ContentPartText, ContentPartImage], Field(discriminator="type")
]


class UserMessage(BaseModel):
    content: str | Sequence[ContentPart] = Field(union_mode="left_to_right")
    """
    The contents of the message.

    `content` is required for all messages, and may be null for assistant messages
    with function calls.
    """

    name: str | None = None
    """
    Used for function messages to indicate the name of the function that was called.
    Function return data is provided in the `content` field.
    """

    files: Sequence[Annotated[str | Path, Field(union_mode="left_to_right")]] = Field(
        default_factory=list
    )

    role: Literal["user"] = "user"


T = TypeVar("T", bound=BaseModel)


class AssistantMessage(BaseModel):
    content: str
    """
    The contents of the message.

    `content` is required for all messages, and may be null for assistant messages
    with function calls.
    """

    reasoning: str | None = None
    """The reasoning behind the assistant's response."""

    tool_calls: Sequence[ToolCall] = field(default_factory=list)
    """The tool calls generated by the model, such as function calls."""

    role: Literal["assistant"] = "assistant"

    def cast(self, t: type[T]) -> T:
        if t == str:
            try:
                parsed = json.loads(self.content)
                if isinstance(parsed, str):
                    return parsed  # type: ignore
            except json.JSONDecodeError:
                return str(self.content)  # type: ignore
        parsed = json.loads(self.content)
        if issubclass(t, BaseModel):
            return t(**parsed)
        else:

            class Value[V](BaseModel):
                value: V

            return Value[T](value=parsed).value


@dataclass
class ToolMessage:
    content: str
    """
    The contents of the message.

    `content` is required for all messages, and may be null for assistant messages
    with function calls.
    """

    name: str | None = None

    id: str | None = None
    """Tool call that this message is responding to."""

    role: Literal["tool"] = "tool"


Message: TypeAlias = Annotated[
    UserMessage | AssistantMessage | ToolMessage,
    Field(discriminator="role"),
]


def is_message(obj: Any) -> TypeGuard[Message]:
    return isinstance(
        obj,
        (UserMessage, AssistantMessage, ToolMessage),
    )


class ToolCallEvent(BaseModel):
    id: str
    agent: str
    name: str
    display_name: str | None
    description: str | None
    arguments: dict[str, Any]
    result: Any | None = None
    metadata: Any | None = None
    role: Literal["event.tool_call"] = "event.tool_call"


class UserConsentEvent(BaseModel):
    message: str
    response: bool | None = None
    metadata: Any | None = None
    tool: str | None = None
    plugin: str | None = None
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    role: Literal["event.user_consent"] = "event.user_consent"


Event: TypeAlias = Annotated[
    ToolCallEvent | UserConsentEvent, Field(discriminator="role")
]


def is_event(obj: Any) -> TypeGuard[Event]:
    return isinstance(obj, (ToolCallEvent, UserConsentEvent))


__all__ = [
    "ToolCall",
    "FunctionCall",
    "FunctionCallDict",
    "ContentPart",
    "ContentPartText",
    "ContentPartImage",
    "Role",
    # Message types
    "Message",
    "UserMessage",
    "AssistantMessage",
    "ToolMessage",
    # Event types
    "Event",
    "UserConsentEvent",
    "ToolCallEvent",
    # Type guards
    "is_message",
    "is_event",
]
