from pathlib import Path
from typing import (
    AsyncIterator,
    Literal,
    Optional,
    Required,
    TypeAlias,
    TypedDict,
    Union,
    cast,
    Mapping,
    Sequence,
    Any,
)
import json
from dataclasses import dataclass, field
from openai.types.chat import (
    ChatCompletionContentPartTextParam,
    ChatCompletionContentPartImageParam,
)
from enum import StrEnum

JSON: TypeAlias = (
    Mapping[str, "JSON"] | Sequence["JSON"] | str | int | float | bool | None
)


class FunctionCallDict(TypedDict, total=False):
    arguments: Required[str]
    """
    The arguments to call the function with, as generated by the model in JSON
    format. Note that the model does not always generate valid JSON, and may
    hallucinate parameters not defined by your function schema. Validate the
    arguments in your code before calling your function.
    """

    name: Required[str]
    """The name of the function to call."""


@dataclass
class FunctionCall:
    name: str
    arguments: JSON

    def arguments_string(self) -> str:
        return json.dumps(self.arguments)

    def to_dict(self) -> FunctionCallDict:
        return {
            "name": self.name,
            "arguments": self.arguments_string(),
        }

    @staticmethod
    def from_dict(d: FunctionCallDict) -> "FunctionCall":
        return FunctionCall(
            name=d["name"],
            arguments=json.loads(d["arguments"]),
        )


@dataclass
class ToolCall:
    id: str
    function: FunctionCall
    type: Literal["function"]

    @staticmethod
    def from_dict(d: Mapping[str, Any]) -> "ToolCall":
        return ToolCall(
            id=d["id"],
            function=FunctionCall.from_dict(d["function"]),
            type=d["type"],
        )

    def to_dict(self) -> Mapping[str, Any]:
        return {
            "id": self.id,
            "function": self.function.to_dict(),
            "type": self.type,
        }


Role: TypeAlias = Literal["system", "user", "assistant", "tool"]


class ContentPartText:
    def __init__(self, content: str) -> None:
        self.content = content

    def to_openai_content_part(self) -> ChatCompletionContentPartTextParam:
        return {"type": "text", "text": self.content}


class ContentPartImage:
    def __init__(self, url: str) -> None:
        self.url = url

    def to_openai_content_part(self) -> ChatCompletionContentPartImageParam:
        return {"type": "image_url", "image_url": {"url": self.url}}


ContentPart = Union[ContentPartText, ContentPartImage]


@dataclass
class Message:
    role: Role
    """The role of the messages author.

    One of `system`, `user`, `assistant`, or `function`.
    """

    content: Optional[str | Sequence[ContentPart]] = None
    """The contents of the message.

    `content` is required for all messages, and may be null for assistant messages
    with function calls.
    """

    name: Optional[str] = None
    """
    Used for function messages to indicate the name of the function that was called.
    Function return data is provided in the `content` field.
    """

    tool_calls: Sequence[ToolCall] = field(default_factory=list)
    """The tool calls generated by the model, such as function calls."""

    tool_call_id: Optional[str] = None
    """Tool call that this message is responding to."""

    files: Optional[Sequence[Path | str]] = None
    """The files that will be sent with the message. Only valid for user messages with assistant api."""

    type: Literal["message"] = "message"

    def to_json(self) -> JSON:
        data: Mapping[str, Any] = {
            "role": self.role,
            "content": self.content,
        }
        if self.name is not None:
            data["name"] = self.name
        return data

    def to_dict(self) -> Mapping[str, Any]:
        data: Mapping[str, Any] = {
            "role": self.role,
            "content": (
                self.content
                if isinstance(self.content, str) or self.content is None
                else [c.to_openai_content_part() for c in self.content]
            ),
            "tool_calls": [tc.to_dict() for tc in self.tool_calls],
        }
        if self.name is not None:
            data["name"] = self.name
        if self.tool_call_id is not None:
            data["tool_call_id"] = self.tool_call_id
        if self.files is not None:
            data["files"] = [str(f) for f in self.files]
        return data

    @staticmethod
    def from_dict(data: Any) -> "Message":
        data = cast(Mapping[str, Any], data)
        assert data["role"] in ["system", "user", "assistant", "tool"]
        return Message(
            role=data["role"],
            content=(
                data["content"]
                if isinstance(data["content"], str) or data["content"] is None
                else [
                    (
                        ContentPartText(c["text"])
                        if c["type"] == "text"
                        else ContentPartImage(c["image_url"]["url"])
                    )
                    for c in data["content"]
                ]
            ),
            name=data.get("name"),
            tool_calls=[ToolCall.from_dict(tc) for tc in data.get("tool_calls", [])],
            tool_call_id=data.get("tool_call_id"),
            files=data.get("files"),
            type="message",
        )


@dataclass
class ServerError(RuntimeError):
    message: Optional[str] = None


class MessageStream:
    type: Literal["message.stream"] = "message.stream"

    def __aiter__(self) -> AsyncIterator[str]:
        raise NotImplementedError()

    async def wait_for_completion(self) -> Message:
        raise NotImplementedError()
