from typing import Literal, Optional, TypeAlias, cast, Mapping, Sequence, Any
import json
from dataclasses import dataclass
from openai.types.chat.chat_completion_chunk import ChatCompletionChunk
import openai
from openai.types.chat import (
    ChatCompletionChunk,
    ChatCompletionMessageParam,
    ChatCompletionMessage,
)
import asyncio
from enum import StrEnum

JSON: TypeAlias = (
    Mapping[str, "JSON"] | Sequence["JSON"] | str | int | float | bool | None
)


@dataclass
class FunctionCall:
    name: str
    arguments: JSON


class Role(StrEnum):
    SYSTEM = "system"
    USER = "user"
    ASSISTANT = "assistant"
    FUNCTION = "function"

    @staticmethod
    def from_str(s: str) -> "Role":
        assert s in ["system", "user", "assistant", "function"]
        return Role(s)


@dataclass
class Message:
    Role = Role
    role: Role
    """The role of the messages author.

    One of `system`, `user`, `assistant`, or `function`.
    """
    content: Optional[str] = None
    """The contents of the message.

    `content` is required for all messages, and may be null for assistant messages
    with function calls.
    """
    name: Optional[str] = None
    """The name of the author of this message.

    `name` is required if role is `function`, and it should be the name of the
    function whose response is in the `content`. May contain a-z, A-Z, 0-9, and
    underscores, with a maximum length of 64 characters.
    """
    function_call: Optional[FunctionCall] = None
    """
    The name and arguments of a function that should be called, as generated by the
    model.
    """

    # def __post_init__(self):
    # if self.function_call is not None and isinstance(self.function_call.arguments, str):
    #     self.function_call = json.loads(json.dumps((self.function_call)))

    def to_json(self) -> JSON:
        data: Mapping[str, Any] = {
            "role": self.role,
            "content": self.content,
        }
        if self.name is not None:
            data["name"] = self.name
        if self.function_call is not None:
            data["function_call"] = {
                "name": self.function_call.name,
                "arguments": self.function_call.arguments,
            }
        return data

    def to_chat_completion_message_param(self) -> ChatCompletionMessageParam:
        if self.function_call is not None:
            return ChatCompletionMessageParam(
                content=self.content,
                role=self.role.value,
                name=self.name or self.function_call.name,
                function_call={
                    "name": self.function_call.name,
                    "arguments": json.dumps(self.function_call.arguments),
                },
            )
        elif self.name is not None:
            return ChatCompletionMessageParam(
                content=self.content, role=self.role.value, name=self.name
            )
        else:
            return ChatCompletionMessageParam(
                content=self.content, role=self.role.value
            )

    @staticmethod
    def from_chat_completion_message(m: ChatCompletionMessage) -> "Message":
        return Message(
            role=Role.from_str(m.role),
            content=m.content,
            name=m.function_call.name if m.function_call is not None else None,
            function_call=FunctionCall(
                name=m.function_call.name,
                arguments=json.loads(m.function_call.arguments),
            )
            if m.function_call is not None
            else None,
        )


class MessageStream:
    def __init__(
        self,
        response: Optional[openai.AsyncStream[ChatCompletionChunk]],
        final_message: Optional[Message] = None,
    ):
        self.__response = response
        self.__message = Message(role=Role.ASSISTANT)
        self.__final_message = final_message

    async def __anext__impl(self) -> str:
        if self.__final_message is not None:
            raise StopAsyncIteration()
        try:
            chunk = await anext(
                cast(openai.AsyncStream[ChatCompletionChunk], self.__response)
            )
        except StopAsyncIteration:
            if self.__message.function_call is not None:
                args = cast(str, self.__message.function_call.arguments).strip()
                if len(args) == 0:
                    self.__message.function_call.arguments = {}
                else:
                    self.__message.function_call.arguments = json.loads(args)
            self.__final_message = self.__message
            raise StopAsyncIteration()
        delta = chunk.choices[0].delta
        # merge self.__message and delta
        if delta.content is not None:
            if self.__message.content is None:
                self.__message.content = ""
            self.__message.content += delta.content
        if delta.function_call is not None:
            if self.__message.function_call is None:
                self.__message.function_call = FunctionCall(name="", arguments="")
            if delta.function_call.name is not None:
                self.__message.function_call.name += delta.function_call.name
            if delta.function_call.arguments is not None:
                if self.__message.function_call.arguments is None:
                    s = cast(str, self.__message.function_call.arguments or "")
                    self.__message.function_call.arguments = (
                        s + delta.function_call.arguments
                    )
        if delta.role is not None:
            self.__message.role = Role.from_str(delta.role)
        return delta.content or ""

    async def __anext__(self) -> str:
        while True:
            delta = await self.__anext__impl()
            if len(delta) > 0:
                return delta

    def __aiter__(self):
        return self

    def __next__(self) -> str:
        if self.__final_message is not None:
            raise StopIteration()
        loop = asyncio.get_event_loop()
        try:
            result = loop.run_until_complete(self.__anext__())
            return result
        except StopAsyncIteration:
            raise StopIteration()

    def __iter__(self):
        return self

    def message(self) -> Message:
        if self.__final_message is not None:
            return self.__final_message
        for _ in self:
            ...
        assert self.__final_message is not None
        return self.__final_message
