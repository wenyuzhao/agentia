from typing import Literal, Optional, TypeAlias, cast
import json
from dataclasses import dataclass
from openai.types.chat.chat_completion_chunk import ChatCompletionChunk
import openai
from openai.types.chat import (
    ChatCompletionChunk,
    ChatCompletionMessageParam,
    ChatCompletionMessage,
)

JSON: TypeAlias = dict[str, "JSON"] | list["JSON"] | str | int | float | bool | None


@dataclass
class FunctionCall:
    name: str
    arguments: JSON


@dataclass
class Message:
    role: Literal["system", "user", "assistant", "function"]
    """The role of the messages author.

    One of `system`, `user`, `assistant`, or `function`.
    """
    content: Optional[str] = None
    """The contents of the message.

    `content` is required for all messages, and may be null for assistant messages
    with function calls.
    """
    name: Optional[str] = None
    """The name of the author of this message.

    `name` is required if role is `function`, and it should be the name of the
    function whose response is in the `content`. May contain a-z, A-Z, 0-9, and
    underscores, with a maximum length of 64 characters.
    """
    function_call: Optional[FunctionCall] = None
    """
    The name and arguments of a function that should be called, as generated by the
    model.
    """

    # def __post_init__(self):
    # if self.function_call is not None and isinstance(self.function_call.arguments, str):
    #     self.function_call = json.loads(json.dumps((self.function_call)))

    def to_json(self) -> JSON:
        data: JSON = {
            "role": self.role,
            "content": self.content,
        }
        if self.name is not None:
            data["name"] = self.name
        if self.function_call is not None:
            data["function_call"] = {
                "name": self.function_call.name,
                "arguments": self.function_call.arguments,
            }
        return data

    def to_chat_completion_message_param(self) -> ChatCompletionMessageParam:
        if self.function_call is not None:
            return ChatCompletionMessageParam(
                content=self.content,
                role=self.role,
                name=self.name or self.function_call.name,
                function_call={
                    "name": self.function_call.name,
                    "arguments": json.dumps(self.function_call.arguments),
                },
            )
        elif self.name is not None:
            return ChatCompletionMessageParam(
                content=self.content, role=self.role, name=self.name
            )
        else:
            return ChatCompletionMessageParam(content=self.content, role=self.role)

    @staticmethod
    def from_chat_completion_message(m: ChatCompletionMessage) -> "Message":
        return Message(
            role=m.role,
            content=m.content,
            name=m.function_call.name if m.function_call is not None else None,
            function_call=FunctionCall(
                name=m.function_call.name,
                arguments=json.loads(m.function_call.arguments),
            )
            if m.function_call is not None
            else None,
        )


class MessageStream:
    def __init__(
        self,
        response: Optional[openai.Stream[ChatCompletionChunk]],
        final_message: Optional[Message] = None,
    ):
        self.__response = response
        self.__message = Message(role="assistant")
        self.__final_message = final_message

    def __next__(self):
        if self.__final_message is not None:
            raise StopIteration()
        chunk = next(cast(openai.Stream[ChatCompletionChunk], self.__response))
        delta = chunk.choices[0].delta
        # merge self.__message and delta
        if delta.content is not None:
            if self.__message.content is None:
                self.__message.content = ""
            self.__message.content += delta.content
        if delta.function_call is not None:
            if self.__message.function_call is None:
                self.__message.function_call = FunctionCall(name="", arguments="")
            if delta.function_call.name is not None:
                self.__message.function_call.name += delta.function_call.name
            if delta.function_call.arguments is not None:
                self.__message.function_call.name += delta.function_call.arguments
        if delta.role is not None:
            self.__message.role = delta.role
        return delta

    def __iter__(self):
        return self

    def message(self) -> Message:
        if self.__final_message is not None:
            return self.__final_message
        for _ in self:
            ...
        return self.__message
