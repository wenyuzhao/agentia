from pathlib import Path
from typing import (
    AsyncIterator,
    Literal,
    Optional,
    Required,
    TypeAlias,
    TypedDict,
    Union,
    cast,
    Mapping,
    Sequence,
    Any,
)
import json
from dataclasses import dataclass, field
from openai.types.chat import (
    ChatCompletionContentPartTextParam,
    ChatCompletionContentPartImageParam,
)
from enum import StrEnum

JSON: TypeAlias = (
    Mapping[str, "JSON"] | Sequence["JSON"] | str | int | float | bool | None
)


class FunctionCallDict(TypedDict, total=False):
    arguments: Required[str]
    """
    The arguments to call the function with, as generated by the model in JSON
    format. Note that the model does not always generate valid JSON, and may
    hallucinate parameters not defined by your function schema. Validate the
    arguments in your code before calling your function.
    """

    name: Required[str]
    """The name of the function to call."""


@dataclass
class FunctionCall:
    name: str
    arguments: JSON

    def arguments_string(self) -> str:
        return json.dumps(self.arguments)

    def to_dict(self) -> FunctionCallDict:
        return {
            "name": self.name,
            "arguments": self.arguments_string(),
        }

    @staticmethod
    def from_dict(d: FunctionCallDict) -> "FunctionCall":
        return FunctionCall(
            name=d["name"],
            arguments=json.loads(d["arguments"]),
        )


@dataclass
class ToolCall:
    id: str
    function: FunctionCall
    type: Literal["function"]


class Role(StrEnum):
    SYSTEM = "system"
    USER = "user"
    ASSISTANT = "assistant"
    FUNCTION = "function"
    TOOL = "tool"

    @staticmethod
    def from_str(s: str) -> "Role":
        assert s in ["system", "user", "assistant", "function"]
        return Role(s)


class ContentPartText:
    def __init__(self, content: str) -> None:
        self.content = content

    def to_openai_content_part(self) -> ChatCompletionContentPartTextParam:
        return {"type": "text", "text": self.content}


class ContentPartImage:
    def __init__(self, url: str) -> None:
        self.url = url

    def to_openai_content_part(self) -> ChatCompletionContentPartImageParam:
        return {"type": "image_url", "image_url": {"url": self.url}}


ContentPart = Union[ContentPartText, ContentPartImage]


@dataclass
class Message:
    Role = Role
    role: Role
    """The role of the messages author.

    One of `system`, `user`, `assistant`, or `function`.
    """

    content: Optional[str | Sequence[ContentPart]] = None
    """The contents of the message.

    `content` is required for all messages, and may be null for assistant messages
    with function calls.
    """

    name: Optional[str] = None
    """
    Used for function messages to indicate the name of the function that was called.
    Function return data is provided in the `content` field.
    """

    tool_calls: Sequence[ToolCall] = field(default_factory=list)
    """The tool calls generated by the model, such as function calls."""

    tool_call_id: Optional[str] = None
    """Tool call that this message is responding to."""

    files: Optional[Sequence[Path | str]] = None
    """The files that will be sent with the message. Only valid for user messages with assistant api."""

    type: Literal["message"] = "message"

    def to_json(self) -> JSON:
        data: Mapping[str, Any] = {
            "role": self.role,
            "content": self.content,
        }
        if self.name is not None:
            data["name"] = self.name
        return data


@dataclass
class ServerError(RuntimeError):
    message: Optional[str] = None


class MessageStream:
    type: Literal["message.stream"] = "message.stream"

    def __aiter__(self) -> AsyncIterator[str]:
        raise NotImplementedError()

    async def wait_for_completion(self) -> Message:
        raise NotImplementedError()
